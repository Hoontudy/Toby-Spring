# 6.8 트랙잭션 지원 테스트
## 6.8.1 선언적 트랜잭션과 트랙젹션 전파 속성
- 트랜잭션 전파속성은 매우 중요하며 보통 REQUIRED 이다
- REQUIRED는 앞에 진행중인 트랜잭션이 있으면 참여하고 없으면 자동으로 새로운 트랜잭션을 만든다
- 이를 통해 불필요한 코드 중복을 피할 수 있고 작은 기능 단위로 애플리케이션을 쪼개서 개발 가능하다
- 보통 DB 트랜잭션은 단위 업무와 일치해야 한다
- 따라서 서비스 메서드 내부에서 add, delete 와 같은 메소드들을 실행하며 해당 트랜잭션은 메서드 단이 즉 단위 업무로 적용한다
- 스프링의 트랜잭션 전파 속성을 선언적으로 사용할 수 있어 편리하게 사용가능핟

![img.png](img.png)

- 선언적 트랜잭션 : AOP를 이용해 코드 외부에서 트랜잭션 기능을 부여 속성 지정
- 프로그램에 의한 트랜잭션 : TransactionTeplate 이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에서 사용하는 방법
- 보통 선언적 트랜잭션을 사용한다

## 6.8.2 트랜잭션 동기화와 테스트
- AOP 덕분에 프록시를 이용한 트랜잭션 부가기능을 간단하게 애플리케이션 전반에 적용 가능하다
- 트랜잭션 추상화 : 데이터 액세스 기술에 상관없이, 트래잭션 기술에 상관없이 DAO에서 일어나는 작업들을 하나의 트랜잭션으로 묶어서 추상 레벨에서 관리하게 해줌

### 트랜잭션 매니저와 트랜잭션 동기화
- PlatformTransactionManger 를 구현한 트랜잭션 매니저를 통해 구체적인 트랜잭션 기술의 종류와 상관없이 트랜잭션 제어가 ㄱ사능하다
- 트랜잭션 동기화 기술이 있었기에 시작된 트랜잭션 정보를 저장소에 보관했다가 DAO에서 공유할 수 있다.
- 진행중인 트랜잭션이 있는지 확인하고, 트랜잭션 전파속성에 따라서 이에 참여할 수 있도록 만들어주는것도 트랜잭션 동기화 기술 덕분이다.
- 모든 트랜잭션을 선언적으로 AOP로 적용하고 있지만, 필요시 프로그램에 의한 트래잭션 방식을 함께 사용할 수도 있다
- 그 예시가 바로 테스트이다
- @Autowired 를 통해 트랜잭션 매니저를 빈에서 가져올 수 있다.

![img_1.png](img_1.png)
- UserService 의 모든 메서드에는 트랜잭션을 적용하니 3개가 실행된다

### 트랜잭션 매니저를 이용한 테스트용 트랜잭션 제어
![img_2.png](img_2.png)
- 트랜잭션 매니저를 이용해 트랜잭션을 시작시키고 이를 동기화 하면 1개의 트랜잭션만 사용한다

### 트랜잭션 동기화 검증
- readOnly 설정을 true 로 하고 deleteAll 하며 에러뜰거다
- 결론적으로 스프링의 트랜잭션 추상화가 제공하는 트랜잭션 동기화 기술과 트랜잭션 전파 속성 덕분에 테스트도 트랜잭션으로 묶을 수 있다.
- 이를 잘 이용하면 DB 작업이 포함되는 테스트를 원하는 대로 제어하면서 효과적인 테스트를 만들 수 있다.

### 롤백 테스트
- 기존의 데이터를 수정하는 것은 이후 테스트에 영향을 미칠 수 있고, 성공 실패에 따른 DB 영향도 고려해야한다
- 따라서 롤백은 중요하다
- 롤백 테스트는 조작한 모든 데이터를 수행하기 전 상태로 돌리기 때문이다
- 롤백 테스트가 보장되면 테스트에서 트랜잭션제어가 가능해 동시에 여러개의 테스트가 진행되어도 문제없다

## 6.8.3 테스트를 위한 트랜잭션 애노테이션
### @Transactional
- 어노테이션으로도 트랜잭션이 가능한 테스트를 쉽게 만든다
- 테스트 메소드에 트랜잭션 경계를 자동으로 설정한다
- 모든 종류의 트랜잭션 속성ㅇㄹ 지정할 수 있다
- 메소드가 아닌 클래스 레벨에 부여 가능하다
- 메소드가 클래스 보다 우선된다

### @Rollback
- 테스트용 트랜잭션은 테스트가 끝나면 자동으로 롤백된다
- 이를 막기 위해 false 로 지정하면 가능하다

### @TransactionConfiguration
- @Transactional 은 클래스, 메서도 둘다 적용가능하지만 @Rollback 은 메소드 레벨만 가능하다
- @Rollback 을 클래스로 적용하고 싶으면 @TransactionConfiguration 을 사용하면 된다.

### NotTransactional, Propagation.NEVEL
- 트랜잭션을 시작않하고 싶은 경우
- `Transactional(propagation=Propagation.NEVER)`을 사용해라

### 효과적인 DB 테스트
- 단위테스트와 통합 테스트는 아예 클래스를 구분하라
- DB가 사용되는 통합테스트를 별도의 클래스로 만든다면 기본적으로 클래스 레벨에 @Transactional 을 부여해라
- 또한 롤백 테스트로만들어라
- 롤백 테스트가 가능시 동시에 테스트도 가능하다
- 테스트는 어떤 경우에도 서로 의존하면 안된다
- 순서나 앞의 성공여부로 결과가 달라지는 테스트는 만들지 말아라
